1）首先，用两个临时变量，一个是 `cur_max`用来保存当前已求得的最大和，另一个`cur_sum`保存当前正在累加的子数组的和。

2）数组从头向后依次遍历，如果当前数组值`arr[i]`非负，`cur_sum += arr[i]`，如果`arr[i]`为负数则比较`cur_max`和`cur_sum`的大小，更新`cur_max`的值，然后`cur_sum += arr[i]`。这么做的目的是如果遇到了负数，加上该负数以后的`cur_sum`一定比未加该负数之前要小，因此需要和`cur_max`比较一次大小。但是可能有这样的连续子数组，其中包含了负数，但是包含负数的子数组的和要比负数之前、之后的子数组的和都要大。

3）一旦`cur_sum`小于等于0了，就令`cur_sum`等于当前遍历的值，直到遇到一个非负值，然后开始`cur_sum+=arr[i]`，即重复步骤 2）

4）遍历到数组最后，需要再用当前的`cur_sum`与`cur_max`比较一次。

